# QT

## 类(class)

## 图形视图

### Graphic view

#### ==QGraphicScene==

用于防止图元的容器，必须通过与之相连的视图类来显示以及与外界的操作。

1. 可以通过QGraphicScene::addItem()添加图元到场景中。	

#### ==QGraphicView==

提供可视窗口用于显示场景中的图元。在一个场景中可以有多个视图。

#### ==QGraphicItems==

是场景中个个图元的基类，在他的基础上可以继承出各种你图元类。
主要有以下功能

1. 处理鼠标按下，移动，释放，双击，悬停，滚轮和右键菜单事件

2. 处理键盘输入事件。

3. 处理拖拽事件。

4. 分组。

5. 碰撞检测。

   ​	

## 信号槽机制

connect有很多重载


## 布局管理

### 分割窗口 QSplitter class

能够灵活的分割窗口布局
The QSplitter class implement a splittler widget
A splitter lets the user control the sizel fo chils widegts by ==dragging== the boundary between them. Any number of the widgers may be controled by a single splitter. The typicla use of QSplitter is to create severla widget and add them using ==insertWidget()== or ==addWidget()==

### 基本布局 QLayout

qt provide three basic layout which are QHBoxLayout() [horizontal layout], QVBoxLayout() [vertical layout] QGridLayout [grid layout].

他们的继承关系是

Qlayout : QBoxLayout QGridLayout
QBoxLayout : QHBoxLayout QVBoxLayout



## qt meta-object complier

简称元对象编译器 moc

==offical wibset==
the meta-object complier, moc, is the program that handels Qt's C++ extensions.

The moc tool reads a C++ header file. if it finds one or more class declarations that contain the ==Q_OBJEET== ==macro==. if product is  a C++ source file containing the meta-object code or those class. Among other things, meta-object code is required fore signal and slots mechanism, the runtime type information ,and the dynamic property system.

the C++ soutce file generated by moc must be complied and linked with the implementation of the class.

if you use qmake to create your makefiles,build rules will be include that call the moc when required, so you will not need to use the moc directly.

```cpp
//example
/****************************************************************************
** Meta object code from reading C++ file 'myfount.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "myfount.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'myfount.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.12.11. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_Widget_t {
    QByteArrayData data[1];
    char stringdata0[7];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Widget_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Widget_t qt_meta_stringdata_Widget = {
    {
QT_MOC_LITERAL(0, 0, 6) // "Widget"

    },
    "Widget"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Widget[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void Widget::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

QT_INIT_METAOBJECT const QMetaObject Widget::staticMetaObject = { {
    &QWidget::staticMetaObject,
    qt_meta_stringdata_Widget.data,
    qt_meta_data_Widget,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *Widget::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Widget::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Widget.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int Widget::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE

```

Too find more ditial message please go to this websit [Using the Meta-Object Compiler (moc) | Qt 6.5](https://doc.qt.io/qt-6/moc.html)

## QThread()

The QThread class povides a platform-independent wya to manage them threads. QThread object maneges one thread of control within the program. QThread begin executing run(). By default run() starts the event loop by calling exec()and run a Qt event loop inside the thread. 
You can use worker object moving them to the thread using QObject::mov To Thread().

members of QThread

```c++
bool QThread::isRunning()const;
//return ==true==if the thread is running ;otherwise return false
bool QThread::isFinished()const;
//return ==true== if te thread is finished; othherwise return false
bool QThread::isinterruptionRequested()const;
//return true if the task running on thhis thread should be stopped. An interruption can be requested by ==requestInterruption().
//
void QThread::wait(unsigned long time = ULOCK_MAX);
//block the thread until either of these condition is met
//	.The thread associated with this QThread object has finished execution (i.e. when it return from run()). This function will return if the thread has finished. It also returns True if the thread has not been started yet.
//	.The milliseconds has elpsed. If timeis ULONE_MAX(the defult), then the wait will never timeout(the thread must return from run()). This functon will return false if the wait time out.
```





 ### QMutex

The porpuse of a QMutxex is to protect a object,  data structor of code so that only one thread cna access it at a time (this is similar to the Java synchornized keyword).  It is sually best to use a mutex with a QMutexLocker since this example, say there is a methord that prints a message to the user on two lines:

## Qt Style Sheet

### the syntax of style sheet

 